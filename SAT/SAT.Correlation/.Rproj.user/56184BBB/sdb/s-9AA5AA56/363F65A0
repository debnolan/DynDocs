{
    "contents" : "library(shiny)\noptions(rgl.useNULL=TRUE)\nlibrary(ggplot2)\nlibrary(scales)\nlibrary(shinyRGL)\nlibrary(rgl)\nlibrary(plyr)\n\n# library(gridExtra)\n# library(grid)\n# library(ggvis)\n\n# Define server logic required to draw a scatterplot\nshinyServer(function(input, output) {\n  load(\"data/satDF.rda\")\n  load(\"data/statepopulation.rda\")\n  \n  output$text <- renderText({\n    input$title\n  })\n  \n  satDF_dataset <- reactive({\n    # adding three columns to the original data frame: region, state population, and state abbreviation.\n    data.frame(satDF, region = state.region, \n               population = statepopulation, state_abb = state.abb)\n  })\n  \n  ###################### sidebyside_1\n  output$sidebyside_1 <- renderPlot({\n    satDF_1 <- satDF_dataset()\n    \n    x <- satDF_1[ , input$x_1]\n    y <- satDF_1[ , input$y_1]\n    \n    dat <- data.frame(x, y, population = satDF_1$population, \n                      region = satDF_1$region, \n                      state_abb = satDF_1$state_abb)\n    \n    p <- ggplot(dat, aes(x, y, size = population, \n                         colour = region, label = state_abb))\n    \n    if(identical(x, satDF_1$expend)| identical(x, satDF_1$salary)){\n      p + geom_point(alpha = 0.8) + \n        ggtitle(paste(input$y_1, \"vs.\", input$x_1)) +\n        xlab(paste(input$x_1, \"(in '000s of dollars)\")) +\n        ylab(input$y_1) + \n        scale_size_continuous(range = c(3, 22), name = \" population in 1994\", labels = comma) +\n        theme_bw() +\n        theme(plot.title = element_text(size = 25),\n              legend.position = \"top\", \n              legend.background = element_rect(fill = \"transparent\", colour = \"transparent\"),\n              legend.key = element_rect(colour = \"transparent\"))\n    }else{\n      p + geom_point(alpha = 0.8) + \n        ggtitle(paste(input$y_1, \"vs.\", input$x_1)) +\n        xlab(input$x_1) +\n        ylab(input$y_1) + \n        scale_size_continuous(range = c(3, 22), name = \" population in 1994\", labels = comma) +\n        theme_bw() +\n        theme(plot.title = element_text(size = 25),\n              legend.position = \"top\", \n              legend.background = element_rect(fill = \"transparent\", colour = \"transparent\"),\n              legend.key = element_rect(colour = \"transparent\"))\n    }}, height = 500, width = 500)\n  \n  ###################### sidebyside_2\n  output$sidebyside_2 <- renderPlot({\n    \n    satDF_2 <- satDF_dataset()\n    \n    x <- satDF_2[ , input$x_2]\n    y <- satDF_2[ , input$y_2]\n    \n    dat <- data.frame(x, y, population = satDF_2$population, \n                 region = satDF_2$region, \n                 state_abb = satDF_2$state_abb)\n    \n    p <- ggplot(dat, aes(x, y, size = population, \n                         colour = region, label = state_abb))\n    \n    if(identical(x, satDF_2$expend)| identical(x, satDF_2$salary)){\n      p + geom_point(alpha = 0.8) + \n        ggtitle(paste(input$y_2, \"vs.\", input$x_2)) +\n        xlab(paste(input$x_2, \"(in '000s of dollars)\")) +\n        ylab(input$y_2) + \n        scale_size_continuous(range = c(3, 22), name = \" population in 1994\", labels = comma) +\n        theme_bw() +\n        theme(plot.title = element_text(size = 25),\n              legend.position = \"top\", \n              legend.background = element_rect(fill = \"transparent\", colour = \"transparent\"),\n              legend.key = element_rect(colour = \"transparent\"))\n    }else{\n      p + geom_point(alpha = 0.8) + \n        ggtitle(paste(input$y_2, \"vs.\", input$x_2)) +\n        xlab(input$x_2) +\n        ylab(input$y_2) + \n        scale_size_continuous(range = c(3, 22), name = \" population in 1994\", labels = comma) +\n        theme_bw() +\n        theme(plot.title = element_text(size = 25),\n              legend.position = \"top\", \n              legend.background = element_rect(fill = \"transparent\", colour = \"transparent\"),\n              legend.key = element_rect(colour = \"transparent\"))\n    }}, height = 500, width = 500)\n  \n  ###################### hover info\n  output$info_1 <- renderPrint({\n    \n    nearPoints(satDF, input$plot_hover_1, xvar = input$x_1, yvar = input$y_1, threshold = 7)\n  })\n  \n  output$info_2 <- renderPrint({\n    nearPoints(satDF, input$plot_hover_2, xvar = input$x_2, yvar = input$y_2, threshold = 7)\n  })\n  \n  ###################### data display\n  output$mytable1 = renderTable({\n    satdata <- satDF_dataset()\n    # remove state name abbreviation column\n    satdata <- satdata[-11]\n    # convert all columns to character vectors\n    satdata$State = state.name\n    satdata$expend = sapply(satdata$expend, function(e) paste(\"$\", as.character(e), sep = \"\"))\n    satdata$salary = sapply(satdata$salary, function(e) paste(\"$\", as.character(e), sep = \"\"))\n    satdata$population= sapply(satdata$population, \n                             function(e) format(e, big.mark=\",\", scientific=FALSE))\n    char_col = as.data.frame(apply(satdata[, c(3, 5, 6, 7, 8)], 2, as.character))\n    satdata = data.frame(\n      \"State\"= satdata$State, \n      \"population\" = satdata$population, \n      \"salary\" = satdata$salary, \n      \"expend\" = satdata$expend,\n      \"frac\" = char_col$frac,\n      \"ratio\" = char_col$ratio,\n      \"sat\" = char_col$sat,\n      \"math\" = char_col$math,\n      \"verbal\" = char_col$verbal)\n    satdata = rename(satdata, c(\"State\" = \"STATE\",\n                      \"population\" = \"POPULATION\",\n                      \"salary\" = \"TEACHER'S SALARY (IN '000S OF DOLLARS)\",\n                      \"expend\" = \"EXPENDITURE PER PUPIL (IN '000S OF DOLLARS)\",\n                     \"frac\" = \"ELIGIBLE STUDENT FRACTION (%)\", \n                     \"ratio\" = \"STUDENT-TEACHER RATIO\", \n                     \"sat\" = \"SAT TOTAL SCORE\",\n                     \"math\" = \"SAT MATH SCORE\", \n                     \"verbal\" = \"SAT VERBAL SCORE\"\n                     ))\n    satdata\n  }, options = list(orderClasses = TRUE))\n \n  \n  \n  ###################### regression \n  nums = list(1:25, 26:50, 1:15, 20:30, 35:50)\n  \n  lm_list = list()\n  for(i in 1:5){  \n    lm_list[[i]] = lm(satDF$sat ~ satDF$salary, subset = order(satDF$frac)[nums[[i]]])\n  }\n  \n  party = list()\n  for(i in 1:5){\n    party[[i]] = satDF[order(satDF$frac)[nums[[i]]], ]\n  }\n  \n  regression = reactive({\n    \n    if (input$model == \"Simple regression\") {\n      fit.res = lm(satDF$sat~ satDF$salary, satDF)\n    } else if (input$model == \"Controlling for frac\") {\n      fit.res = list()\n      fit.res[[1]] = lm_list[[3]]\n      fit.res[[2]] = lm_list[[4]]\n      fit.res[[3]] = lm_list[[5]]\n    } else if (input$model == \"First Half of Data\") {\n      fit.res = lm_list[[1]] \n    } else if (input$model == \"Second Half of Data\") {\n      fit.res = lm_list[[2]]\n    } \n    \n    # Get the model summary\n    if (is.null(fit.res)) {\n      fit.summary = NULL\n    }  else {\n      if (class(fit.res) == \"list\") {\n        fit.summary = list()\n        fit.summary[[1]] = summary(fit.res[[1]])\n        fit.summary[[2]] = summary(fit.res[[2]])\n        fit.summary[[3]] = summary(fit.res[[3]])    \n      } else {\n        fit.summary = summary(fit.res)  \n      }\n    }\n    \n    return(list(fit.res=fit.res, fit.summary=fit.summary))\n    \n  })\n  \n  #---------------------------------------------------------------------------\n  # Plot a scatter of the data with regression lines corresponding to the model\n  output$reg.plot = renderPlot({         \n    \n    x = satDF$salary\n    y = satDF$sat\n    g = satDF$frac\n    coefs = regression()$fit.res$coefficients\n    \n    plot(x, y, pch=16, type= \"n\", cex=1.2, bty=\"n\",xlim=c(25, 50.5), main= \"The Effect of Teacher Salary on SAT scores\", xlab=\"Average Teacher Salary (in thousands of dollars)\", ylab=\"Average Total SAT Scores\")\n    \n    if (input$model == \"Simple regression\") {\n      points(x, y, pch=16, cex=1.2, col=\"black\")\n      abline(coefs, lwd=3, col= \"red\")\n    } else if (input$model == \"Controlling for frac\") {\n      points(x, y, pch=16, cex=1.2, col=\"black\")\n      abline(lm_list[[3]]$coefficients, lwd=3, col= \"blue\")\n      abline(lm_list[[4]]$coefficients, lwd=3, col= \"gold\")\n      abline(lm_list[[5]]$coefficients, lwd=3, col= \"red\")\n      points(party[[3]]$salary, party[[3]]$sat, pch=16, cex=1.2, col=\"blue\")\n      points(party[[4]]$salary, party[[4]]$sat, pch=16, cex=1.2, col=\"gold\")\n      points(party[[5]]$salary, party[[5]]$sat, pch=16, cex=1.2, col=\"red\")\n    } else if (input$model == \"First Half of Data\") {\n      points(x, y, pch=16, cex=1.2, col=\"black\")\n      points(party[[1]]$salary, party[[1]]$sat, pch=16, cex=1.2, col=\"red\")      \n      abline(lm_list[[1]]$coefficients, lwd=3, col= \"red\") \n    } else if (input$model == \"Second Half of Data\") {\n      points(x, y, pch=16, cex=1.2, col=\"black\")\n      points(party[[2]]$salary, party[[2]]$sat, pch=16, cex=1.2, col=\"red\")\n      abline(lm_list[[2]]$coefficients, lwd=3, col= \"red\")\n    }    \n  })\n  \n  \n  #---------------------------------------------------------------------------\n  \n  #####################################\n  \n  #Show the lm() summary for the \n  output$reg.summary <- renderPrint({\n    \n    summary <- regression()$fit.summary\n    if (!is.null(summary)) {\n      return(regression()$fit.summary)\n    }\n  })\n  \n   \n  ###################### Simpson's Paradox tutorial 1\n  count_rate_values <- reactive({\n    success_rate_A_small = 0.93\n    success_rate_A_large = 0.73\n    success_rate_B_small = 0.87\n    success_rate_B_large = 0.69\n    \n    # Treatment A values\n    success_count_A_small = \n      round(success_rate_A_small * input$count_A_small, digits = 0)\n    success_count_A_large = \n      round(success_rate_A_large * (350 - input$count_A_small), digits = 0)\n    success_count_A_both = \n      round((success_count_A_small + success_count_A_large), digits = 0)\n    success_rate_A_both =\n      round((success_count_A_small + success_count_A_large)/ 350 * 100, digits = 0)\n    \n    # Treatment B values\n    success_count_B_small = \n      round(success_rate_B_small * input$count_B_small, digits = 0)\n    success_count_B_large = \n      round(success_rate_B_large * (350 - input$count_B_small), digits = 0)\n    success_count_B_both = \n      round((success_count_B_small + success_count_B_large), digits = 0)\n    success_rate_B_both = \n      round((success_count_B_small + success_count_B_large)/ 350 *100, digits = 0)\n    \n    countA = c(success_count_A_small, success_count_A_large, success_count_A_both)\n    rateA = c(success_rate_A_small, success_rate_A_large, success_rate_A_both)\n    countB = c(success_count_B_small, success_count_B_large, success_count_B_both)\n    rateB = c(success_rate_B_small, success_rate_B_large, success_rate_B_both)\n    \n    as.data.frame(cbind(countA, rateA, countB, rateB))\n    \n  })\n  \n  cell_values <- reactive({\n    df <- count_rate_values()\n    # df <- apply(df, 2, as.character)\n    cell11count = paste(df[1,1], \"/\", as.character(input$count_A_small), sep = \"\")\n    cell21count = paste(df[2,1], \"/\", as.character(350 - input$count_A_small), sep = \"\")\n    cell31count = paste(df[3,1], \"/\", \"350\", sep = \"\")\n    cell11rate = paste(df[1,2] * 100, \"%\", sep = \"\")\n    cell21rate = paste(df[2,2] * 100, \"%\", sep = \"\")\n    cell31rate = paste(df[3,2], \"%\", sep = \"\")\n    \n    cell12count = paste(df[1,3], \"/\", as.character(input$count_B_small), sep = \"\")\n    cell22count = paste(df[2,3], \"/\", as.character(350 - input$count_B_small), sep = \"\")\n    cell32count = paste(df[3,3], \"/\", \"350\", sep = \"\")\n    cell12rate = paste(df[1,4] * 100, \"%\", sep = \"\")\n    cell22rate = paste(df[2,4] * 100, \"%\", sep = \"\")\n    cell32rate = paste(df[3,4], \"%\", sep = \"\")\n    \n    df <- data.frame(\n      cases = c(\"Small Stones\", \"Large Stones\", \"Both\"),\n      treatmentA = c(paste(cell11count, \" \", \"(\", cell11rate, \")\", sep = \"\"), \n                     paste(cell21count, \" \", \"(\", cell21rate, \")\", sep = \"\"), \n                     paste(cell31count, \" \", \"(\", cell31rate, \")\", sep = \"\")),\n      treatmentB = c(paste(cell12count, \" \", \"(\", cell12rate, \")\", sep = \"\"), \n                     paste(cell22count, \" \", \"(\", cell22rate, \")\", sep = \"\"), \n                     paste(cell32count, \" \", \"(\", cell32rate, \")\", sep = \"\")),\n      \n      stringsAsFactors = FALSE)\n    \n    rename(df, c(\"cases\"= \"Severity\",\n                 \"treatmentA\" = \"Treatment A\", \n                 \"treatmentB\" = \"Treatment B\"))\n  }) \n  \n  \n  # Show the values using an HTML table\n  output$table <- renderTable({cell_values()})\n  \n  output$yesorno <- renderText({\n    dfi<- count_rate_values()\n    if(isTRUE(dfi[3,2] < dfi[3,4])){\n      print(\"Simpson's Paradox: YES\")\n    }else{\n      print(\"Simpson's Paradox: NO\")\n    }\n  })  \n  \n  ###################### Simpson's Paradox tutorial 2\n  \n  count_rate_values2 <- reactive({\n    success_rate_A_small2= input$success_rate_A_small2\n    success_rate_A_large2= input$success_rate_A_large2 \n    success_rate_B_small2= input$success_rate_B_small2\n    success_rate_B_large2= input$success_rate_B_large2\n    \n    # Treatment A values\n    success_count_A_small2 = \n      round(success_rate_A_small2* input$count_A_small2, digits = 0)\n    success_count_A_large2 = \n      round(success_rate_A_large2 * (350 - input$count_A_small2), digits = 0)\n    success_count_A_both2 = \n      round((success_count_A_small2 + success_count_A_large2), digits = 0)\n    success_rate_A_both2 =\n      round((success_count_A_small2 + success_count_A_large2)/ 350 * 100, digits = 0)\n    \n    # Treatment B values\n    success_count_B_small2 = \n      round(success_rate_B_small2 * input$count_B_small2, digits = 0)\n    success_count_B_large2 = \n      round(success_rate_B_large2 * (350 - input$count_B_small2), digits = 0)\n    success_count_B_both2 = \n      round((success_count_B_small2 + success_count_B_large2), digits = 0)\n    success_rate_B_both2 = \n      round((success_count_B_small2 + success_count_B_large2)/ 350 * 100, digits = 0)\n    \n    df2 <- as.data.frame(cbind(c(success_count_A_small2, success_count_A_large2, success_count_A_both2), \n                               c(success_rate_A_small2, success_rate_A_large2, success_rate_A_both2),\n                               c(success_count_B_small2, success_count_B_large2, success_count_B_both2),\n                               c(success_rate_B_small2, success_rate_B_large2, success_rate_B_both2)))\n    \n  })\n  \n  cell_values2 <- reactive({\n    df2 <- count_rate_values2()\n    #     df2 <- apply(df2, 2, as.character)\n    cell11count2 = paste(df2[1,1], \"/\", as.character(input$count_A_small2), sep = \"\")\n    cell21count2 = paste(df2[2,1], \"/\", as.character(350 - input$count_A_small2), sep = \"\")\n    cell31count2 = paste(df2[3,1], \"/\", \"350\", sep = \"\")\n    cell11rate2 = paste(df2[1,2] * 100, \"%\", sep = \"\")\n    cell21rate2 = paste(df2[2,2] * 100, \"%\", sep = \"\")\n    cell31rate2 = paste(df2[3,2], \"%\", sep = \"\")\n    \n    cell12count2 = paste(df2[1,3], \"/\", as.character(input$count_B_small2), sep = \"\")\n    cell22count2 = paste(df2[2,3], \"/\", as.character(350 - input$count_B_small2), sep = \"\")\n    cell32count2 = paste(df2[3,3], \"/\", \"350\", sep = \"\")\n    cell12rate2 = paste(df2[1,4] * 100, \"%\", sep = \"\")\n    cell22rate2 = paste(df2[2,4] * 100, \"%\", sep = \"\")\n    cell32rate2 = paste(df2[3,4], \"%\", sep = \"\")\n    \n    df2 <- data.frame(\n      cases2 = c(\"Small Stones\", \"Large Stones\", \"Both\"),\n      treatmentA2 = c(paste(cell11count2, \" \", \"(\", cell11rate2, \")\", sep = \"\"), \n                      paste(cell21count2, \" \", \"(\", cell21rate2, \")\", sep = \"\"), \n                      paste(cell31count2, \" \", \"(\", cell31rate2, \")\", sep = \"\")),\n      treatmentB2 = c(paste(cell12count2, \" \", \"(\", cell12rate2, \")\", sep = \"\"), \n                      paste(cell22count2, \" \", \"(\", cell22rate2, \")\", sep = \"\"), \n                      paste(cell32count2, \" \", \"(\", cell32rate2, \")\", sep = \"\")),\n      \n      stringsAsFactors = FALSE)\n    \n    rename(df2, c(\"cases2\"= \"Severity\",\n                  \"treatmentA2\" = \"Treatment A\", \n                  \"treatmentB2\" = \"Treatment B\"))\n  }) \n  \n  \n  # Show the values using an HTML table\n  output$table2 <- renderTable({cell_values2()})\n  \n  output$yesorno2 <- renderText({\n    dff<- count_rate_values2()\n    paradox1 = (dff[1,2] < dff[1,4]) & (dff[2,2] < dff[2,4]) & (dff[3,2] > dff[3,4])\n    paradox2 = (dff[1,2] > dff[1,4]) & (dff[2,2] > dff[2,4]) & (dff[3,2] < dff[3,4])\n    if(isTRUE(paradox1)){\n      print(\"Simpson's Paradox: YES\")\n    }else{\n      if(isTRUE(paradox2)){\n        print(\"Simpson's Paradox: YES\")\n      }else{\n        print(\"Simpson's Paradox: NO\")\n      }\n    }\n  })\n})",
    "created" : 1440991413053.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3964344775",
    "id" : "363F65A0",
    "lastKnownWriteTime" : 1440991267,
    "path" : "~/DynDocs/SAT/SAT.Correlation/SATapp/server.R",
    "project_path" : "SATapp/server.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}