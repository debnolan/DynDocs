qqnorm(sample_means)
qqline(sample_means, col = "red", lwd = 2, lty = 3)
set.seed(7)
mysample = sample(na.omit(infants$wt), 100)
###### a)
# mean of mysample
sample_mean = mean(mysample) ## 129.78
# fpc
N = length(na.omit(infants$wt))
n = 100
fpc = sqrt((N - n)/N)  ## 0.9574271
# standard error of the estimate
SE_mean_est = sd(mysample)/sqrt(100) * fpc ## 1.971584
# 95% confidence interval, assuming normality works
# marginal error
me = qnorm(0.975) * SE_mean_est ## 3.864234
lowerbound = sample_mean - me ## 125.9158
upperbound = sample_mean + me ## 133.6442
###### b)
# replicate 1000 times
set.seed(1293)
mysamples = replicate(1000, sample(na.omit(infants$wt), 100))
# mean of the each 1000 samples
sample_means = apply(mysamples, 2, mean)
SE_mean_ests = apply(mysamples, 2, function(e) sd(e)/sqrt(100))
mes = qnorm(0.975) * SE_mean_ests
lowerbounds =  sample_means - mes
upperbounds = sample_means + mes
# check if pop_mean is covered by the confidence interval.
# I'd expect to see true_mean in the C.I. about 95% of the time.
pop_mean = mean(infants$wt, na.rm = T)
per = logical()
for(i in 1:1000){
if (upperbounds[i] >= pop_mean & lowerbounds[i] <= pop_mean){
per[i] = TRUE
}else{
per[i] = FALSE
}
}
# Calculate the percentage of C.I. capturing the true mean
sum(per)/ 1000 ## 0.94
## About 94% of the time the confidence interval covers the true mean.
###### c)
# standard deviation of the sample averages
SD_sampleAverages = sd(sample_means) ## 2.03245
# standard error from 1a
SE_mean_est ## 1.971584
## SD of the 1000 sample averages 2.03, is fairly close to the standard error of the
## estimate, 1.97. This decrease in difference may be a result of a larger sample.
# Histogram of sample averages
hist(sample_means)
# Q_Q plot
qqnorm(sample_means)
qqline(sample_means, col = "red", lwd = 2, lty = 3)
# Since the histogram looks about normal, with a bell shape and peaked around the mean,
# and the Q-Q plot follows closely along the qqline, we can say that the
# confidence interval is valid.
### repeat of 2
###### a)
mysample
bstrap = bootStrap(mysample, popSize = length(na.omit(infants$wt)))
mysample
set.seed(100)
# Construct a bootstrap population and get the sample averages
bstrap = bootStrap(mysample, popSize = length(na.omit(infants$wt)))
bstrap
mysamples
mysample
set.seed(100)
# Construct a bootstrap population and get the sample averages
bstrap = bootStrap(mysample, popSize = length(na.omit(infants$wt)))
# Histogram of sample averages
hist(bstrap$bootSamps)
# Put a vertical line through the average of the bootstrap population
abline(v = mean(bstrap[[1]]), col = "red")
# SD_bstrapsampAverages
sd(bstrap$bootSamps) ## 4.659238
SE_mean_est ## 4.89217
me_bs = qnorm(0.975) * sd(bstrap$bootSamps)
me_bs
lowerbound_bs = mean(bstrap[[2]]) - me_bs ## 125.5432
lowerbound_bs = mean(bstrap[[2]]) - me_bs ## 125.5432
lowerbound_bs = mean(bstrap[[2]]) - me_bs ## 125.5432
upperbound_bs = mean(bstrap[[2]]) + me_bs ## 143.807
lowerbound_bs
upperbound_bs = mean(bstrap[[2]]) + me_bs ## 143.807
upperbound_bs
quantile(bstrap$bootSamps, 0.975) ## 133.4517
quantile(bstrap$bootSamps, 0.025) ## 125.7
load(url("http://www.stat.berkeley.edu/users/nolan/data/KaiserBabies.rda"))
########## 1
set.seed(7)
mysample = sample(na.omit(infants$wt), 10)
###### a)
# mean of mysample
sample_mean = mean(mysample) ## 134.7
# fpc
N = length(na.omit(infants$wt))
n = 10
fpc = sqrt((N - n)/N)  ## 0.9958246
# standard error of the estimate
SE_mean_est = sd(mysample)/sqrt(10) * fpc ## 4.89217
# 95% confidence interval, assuming normality works
# marginal error
me = qnorm(0.975) * SE_mean_est ## 9.588476
lowerbound = sample_mean - me ## 125.1115
upperbound = sample_mean + me ## 144.2885
###### b)
# replicate 1000 times
set.seed(1293)
mysamples = replicate(1000, sample(na.omit(infants$wt), 10))
# mean of the each 1000 samples
sample_means = apply(mysamples, 2, mean)
SE_mean_ests = apply(mysamples, 2, function(e) sd(e)/sqrt(10))
mes = qnorm(0.975) * SE_mean_ests
lowerbounds =  sample_means - mes
upperbounds = sample_means + mes
# check if pop_mean is covered by the confidence interval.
# I'd expect to see true_mean in the C.I. about 95% of the time.
pop_mean = mean(infants$wt, na.rm = T)
per = logical()
for(i in 1:1000){
if (upperbounds[i] >= pop_mean & lowerbounds[i] <= pop_mean){
per[i] = TRUE
}else{
per[i] = FALSE
}
}
# Calculate the percentage of C.I. capturing the true mean
sum(per)/ 1000 ## 0.921
## About 92.1% of the time the confidence interval covers the true mean.
## c)
# standard deviation of the sample averages
SD_sampleAverages = sd(sample_means) ## 6.529769
# standard error from 1a
SE_mean_est ## 4.89217
## SD of the 1000 sample averages, 6.5 is not very close to the standard error of the
## estimate, 4.9. This difference may be a result of a small sample size.
# Histogram of sample averages
hist(sample_means)
# Q_Q plot
qqnorm(sample_means)
qqline(sample_means, col = "red", lwd = 2, lty = 3)
# Since the histogram looks about normal, with a bell shape and peaked around the mean,
# and the Q-Q plot follows closely along the qqline, we can say that the
# confidence interval is valid.
########## 2
###### a)
bootStrap = function(mySample, popSize = NULL, B = 1000, repl = FALSE){
if (repl) {
# Bootstrap should be done the same way as original sample, usually without rep
return(replicate(B, mean(sample(mySample, length(mySample), TRUE))))
} else {
vals = sort(unique(mySample))
counts = table(mySample)
# makes the bootstrap pop as rounded version of sample, not quite right
bootPop = rep(vals, round(counts * popSize / length(mySample)))
return(list(bootPop,
bootSamps = replicate(B,mean(sample(bootPop, length(mySample), FALSE))))
)
}
}
set.seed(100)
# Construct a bootstrap population and get the sample averages
bstrap = bootStrap(mysample, popSize = length(na.omit(infants$wt)))
# Histogram of sample averages
hist(bstrap$bootSamps)
# Put a vertical line through the average of the bootstrap population
abline(v = mean(bstrap[[1]]), col = "red")
# SD_bstrapsampAverages
sd(bstrap$bootSamps) ## 4.659238
SE_mean_est ## 4.89217
## The SD of the sample averages from bootstrapping is close to the estimated SE from 1a.
###### b)
# Calculation of the bootstrap confidence interval
me_bs = qnorm(0.975) * sd(bstrap$bootSamps)
lowerbound_bs = mean(bstrap[[2]]) - me_bs ## 125.5432
upperbound_bs = mean(bstrap[[2]]) + me_bs ## 143.807
# or use the quantile function to get the bootstrap confidence interval
quantile(bstrap$bootSamps, 0.025) ## 125.7
quantile(bstrap$bootSamps, 0.975) ## 143.9025
## This bootstrap confidence interval is very close to the confidence interval from 1a.
########## 3
### repeat of 1
set.seed(7)
mysample = sample(na.omit(infants$wt), 100)
###### a)
# mean of mysample
sample_mean = mean(mysample) ## 129.78
# fpc
N = length(na.omit(infants$wt))
n = 100
fpc = sqrt((N - n)/N)  ## 0.9574271
# standard error of the estimate
SE_mean_est = sd(mysample)/sqrt(100) * fpc ## 1.971584
# 95% confidence interval, assuming normality works
# marginal error
me = qnorm(0.975) * SE_mean_est ## 3.864234
lowerbound = sample_mean - me ## 125.9158
upperbound = sample_mean + me ## 133.6442
###### b)
# replicate 1000 times
set.seed(1293)
mysamples = replicate(1000, sample(na.omit(infants$wt), 100))
# mean of the each 1000 samples
sample_means = apply(mysamples, 2, mean)
SE_mean_ests = apply(mysamples, 2, function(e) sd(e)/sqrt(100))
mes = qnorm(0.975) * SE_mean_ests
lowerbounds =  sample_means - mes
upperbounds = sample_means + mes
# check if pop_mean is covered by the confidence interval.
# I'd expect to see true_mean in the C.I. about 95% of the time.
pop_mean = mean(infants$wt, na.rm = T)
per = logical()
for(i in 1:1000){
if (upperbounds[i] >= pop_mean & lowerbounds[i] <= pop_mean){
per[i] = TRUE
}else{
per[i] = FALSE
}
}
# Calculate the percentage of C.I. capturing the true mean
sum(per)/ 1000 ## 0.94
## About 94% of the time the confidence interval covers the true mean.
###### c)
# standard deviation of the sample averages
SD_sampleAverages = sd(sample_means) ## 2.03245
# standard error from 1a(repeated)
SE_mean_est ## 1.971584
## SD of the 1000 sample averages 2.03, is fairly close to the standard error of the
## estimate, 1.97. This decrease in difference may be a result of a larger sample.
# Histogram of sample averages
hist(sample_means)
# Q_Q plot
qqnorm(sample_means)
qqline(sample_means, col = "red", lwd = 2, lty = 3)
# Since the histogram looks about normal, with a bell shape and peaked around the mean,
# and the Q-Q plot follows closely along the qqline, we can say that the
# confidence interval is valid.
### repeat of 2
###### a)
set.seed(100)
# Construct a bootstrap population and get the sample averages
bstrap = bootStrap(mysample, popSize = length(na.omit(infants$wt)))
# Histogram of sample averages
hist(bstrap$bootSamps)
# Put a vertical line through the average of the bootstrap population
abline(v = mean(bstrap[[1]]), col = "red")
# SD_bstrapsampAverages
sd(bstrap$bootSamps) ## 1.92246
SE_mean_est ## 1.971584
## The SD of the sample averages from bootstrapping is very close to
## the estimated SE from 1a(repeated).
###### b)
# Calculation of the bootstrap confidence interval
me_bs = qnorm(0.975) * sd(bstrap$bootSamps) ## 3.767951
lowerbound_bs = mean(bstrap[[2]]) - me_bs ## 125.9158
upperbound_bs = mean(bstrap[[2]]) + me_bs ## 133.4517
# or use the quantile function to get the bootstrap confidence interval
quantile(bstrap$bootSamps, 0.025) ## 126.0598
quantile(bstrap$bootSamps, 0.975) ## 133.3603
## This bootstrap confidence interval is very close to
## the confidence interval from 1a(repeated).
source('~/Dropbox/STAT135/Lab1/Lab1.R')
load(url("http://www.stat.berkeley.edu/users/nolan/data/KaiserBabies.rda"))
########## 1
set.seed(7)
mysample = sample(na.omit(infants$wt), 10)
###### a)
# mean of mysample
sample_mean = mean(mysample) ## 134.7
# fpc
N = length(na.omit(infants$wt))
n = 10
fpc = sqrt((N - n)/N)  ## 0.9958246
# standard error of the estimate
SE_mean_est = sd(mysample)/sqrt(10) * fpc ## 4.89217
# 95% confidence interval, assuming normality works
# marginal error
me = qnorm(0.975) * SE_mean_est ## 9.588476
lowerbound = sample_mean - me ## 125.1115
upperbound = sample_mean + me ## 144.2885
###### b)
# replicate 1000 times
set.seed(1293)
mysamples = replicate(1000, sample(na.omit(infants$wt), 10))
# mean of the each 1000 samples
sample_means = apply(mysamples, 2, mean)
SE_mean_ests = apply(mysamples, 2, function(e) sd(e)/sqrt(10))
mes = qnorm(0.975) * SE_mean_ests
lowerbounds =  sample_means - mes
upperbounds = sample_means + mes
# check if pop_mean is covered by the confidence interval.
# I'd expect to see true_mean in the C.I. about 95% of the time.
pop_mean = mean(infants$wt, na.rm = T)
per = logical()
for(i in 1:1000){
if (upperbounds[i] >= pop_mean & lowerbounds[i] <= pop_mean){
per[i] = TRUE
}else{
per[i] = FALSE
}
}
# Calculate the percentage of C.I. capturing the true mean
sum(per)/ 1000 ## 0.921
## About 92.1% of the time the confidence interval covers the true mean.
## c)
# standard deviation of the sample averages
SD_sampleAverages = sd(sample_means) ## 6.529769
# standard error from 1a
SE_mean_est ## 4.89217
## SD of the 1000 sample averages, 6.5 is not very close to the standard error of the
## estimate, 4.9. This difference may be a result of a small sample size.
# Histogram of sample averages
hist(sample_means)
qqnorm(sample_means)
qqline(sample_means, col = "red", lwd = 2, lty = 3)
hist(sample_means)
load("data/satDF_new.rda")
output$text <- renderText({
load("../rda_data/satDF_new.rda")
setwd("~/Dropbox/Senior_Research/Stat_Summer15_Research/DynDocs/SAT/rda_data/")
load("~/Dropbox/Senior_Research/Stat_Summer15_Research/DynDocs/SAT/rda_data/satDF.rda")
############################ satDF_one
# data manipulation for easy use of ggplot
# add state.region to satDF
satDF$region = state.region
# scrape state population data from website
# https://www.census.gov/popest/data/state/totals/1990s/tables/ST-99-03.txt
x = readLines("1995_state_population.txt")
x = x[14:78]
statenames = gsub("[^[:alpha:]]", "", x)
pop = strsplit(x, split = " ")
pop = sapply(pop, function(e) e[length(e)])
# remove extra district Columbia
statenames = statenames[-23]
pop = pop[-23]
pop = as.numeric(as.character(pop))
population_df = data.frame(statenames, pop)
# combine population_df[15:65, ] with satDF
satDF_one = cbind(satDF, population = population_df[15:64, 2])
save(satDF_one, file = "satDF_one.rda")
############################ satDF_new
library(plyr)
satDF_new = rename(satDF_one, c("sat" = "SAT_Total_Score",
"math" = "SAT Math Score",
"verbal" = "SAT Verbal Score",
"expend"="Expenditure",
"salary"="Teacher Salary",
"ratio" ="Student-Teacher Ratio",
"frac" = "Eligible Student Fraction",
"region" = "Region",
"population" = "State Population"))
save(satDF_new, file = "../rda_data/satDF_new.rda")
load("../rda_data/satDF_new.rda")
############################ satDF_pretty
# reformat data for display
load("../rda_data/satDF_new.rda")
satDF_new$State = state.name
satDF_new$Expenditure = sapply(satDF_new$Expenditure,
function(e) paste("$", as.character(e), sep = ""))
satDF_new$`Teacher Salary` = sapply(satDF_new$`Teacher Salary`,
function(e) paste("$", as.character(e), sep = ""))
satDF_new$`State Population` = sapply(satDF_new$`State Population`, function(e) format(e, big.mark=",", scientific=FALSE))
char_col = apply(satDF_new[, c(3, 5, 6, 7, 8)], 2, as.character)
satDF_pretty = data.frame(STATE = satDF_new$State,
REGION = satDF_new$Region,
POPULATION = satDF_new$`State Population`,
EXPENDITURE = satDF_new$Expenditure,
TEACHER_SALARY = satDF_new$`Teacher Salary`,
STUDENT_TEACHER_RATIO = char_col[ , 1],
ELIGIBLE_STUDENT_FRACTION = char_col[ , 2],
SAT_TOTAL_SCORE = char_col[ , 5],
SAT_MATH_SCORE = char_col[ , 4],
SAT_VERBAL_SCORE = char_col[ , 3])
satDF_pretty= rename(satDF_pretty, c("STATE" = "STATE",
"REGION" = "REGION",
"POPULATION" = "POPULATION",
"EXPENDITURE" = "EXPENDITURE",
"TEACHER_SALARY" = "TEACHER SALARY",
"STUDENT_TEACHER_RATIO" = "STUDENT-TEACHER RATIO",
"ELIGIBLE_STUDENT_FRACTION" = "ELIGIBLE STUDENT FRACTION",
"SAT_TOTAL_SCORE" = "SAT TOTAL SCORE",
"SAT_MATH_SCORE" = "SAT MATH SCORE",
"SAT_VERBAL_SCORE" = "SAT VERBAL SCORE"))
satDF_pretty = format(satDF_pretty, justify = "right")
save(satDF_pretty, file = "../rda_data/satDF_pretty.rda")
load("../rda_data/satDF_pretty.rda")
View(satDF_pretty)
satDF_new$`Teacher Salary`
Expenditure
sapply(satDF_new$Expenditure,
function(e) paste("$", as.character(e), sep = ""))
load("~/Dropbox/Senior_Research/Stat_Summer15_Research/DynDocs/SAT/rda_data/satDF.rda")
############################ satDF_one
# data manipulation for easy use of ggplot
# add state.region to satDF
satDF$region = state.region
# scrape state population data from website
# https://www.census.gov/popest/data/state/totals/1990s/tables/ST-99-03.txt
x = readLines("1995_state_population.txt")
x = x[14:78]
statenames = gsub("[^[:alpha:]]", "", x)
pop = strsplit(x, split = " ")
pop = sapply(pop, function(e) e[length(e)])
# remove extra district Columbia
statenames = statenames[-23]
pop = pop[-23]
pop = as.numeric(as.character(pop))
population_df = data.frame(statenames, pop)
# combine population_df[15:65, ] with satDF
satDF_one = cbind(satDF, population = population_df[15:64, 2])
save(satDF_one, file = "satDF_one.rda")
############################ satDF_new
library(plyr)
satDF_new = rename(satDF_one, c("sat" = "SAT_Total_Score",
"math" = "SAT Math Score",
"verbal" = "SAT Verbal Score",
"expend"="Expenditure",
"salary"="Teacher Salary",
"ratio" ="Student-Teacher Ratio",
"frac" = "Eligible Student Fraction",
"region" = "Region",
"population" = "State Population"))
save(satDF_new, file = "../rda_data/satDF_new.rda")
load("../rda_data/satDF_new.rda")
View(satDF_new)
View(satDF)
setwd("~/Dropbox/Senior_Research/Stat_Summer15_Research/DynDocs/SAT/rda_data/")
load("~/Dropbox/Senior_Research/Stat_Summer15_Research/DynDocs/SAT/rda_data/satDF.rda")
load("~/Dropbox/Senior_Research/Stat_Summer15_Research/DynDocs/SAT/rda_data/satDF.rda")
satDF$region = state.region
setwd("~/Dropbox/Senior_Research/Stat_Summer15_Research/DynDocs/SAT/rda_data/")
load("~/Dropbox/Senior_Research/Stat_Summer15_Research/DynDocs/SAT/rda_data/satDF.rda")
############################ satDF_one
# data manipulation for easy use of ggplot
# add state.region to satDF
satDF$region = state.region
# scrape state population data from website
# https://www.census.gov/popest/data/state/totals/1990s/tables/ST-99-03.txt
x = readLines("1995_state_population.txt")
x = x[14:78]
statenames = gsub("[^[:alpha:]]", "", x)
pop = strsplit(x, split = " ")
pop = sapply(pop, function(e) e[length(e)])
# remove extra district Columbia
statenames = statenames[-23]
pop = pop[-23]
pop = as.numeric(as.character(pop))
population_df = data.frame(statenames, pop)
# combine population_df[15:65, ] with satDF
satDF_one = cbind(satDF, population = population_df[15:64, 2])
save(satDF_one, file = "satDF_one.rda")
############################ satDF_new
library(plyr)
satDF_new = rename(satDF_one, c("sat" = "SAT_Total_Score",
"math" = "SAT Math Score",
"verbal" = "SAT Verbal Score",
"expend"="Expenditure",
"salary"="Teacher Salary",
"ratio" ="Student-Teacher Ratio",
"frac" = "Eligible Student Fraction",
"region" = "Region",
"population" = "State Population"))
save(satDF_new, file = "../rda_data/satDF_new.rda")
load("../rda_data/satDF_new.rda")
############################ satDF_pretty
# reformat data for display
load("../rda_data/satDF_new.rda")
satDF_new$State = state.name
satDF_new$Expenditure = sapply(satDF_new$Expenditure,
function(e) paste("$", as.character(e), sep = ""))
satDF_new$`Teacher Salary` = sapply(satDF_new$`Teacher Salary`,
function(e) paste("$", as.character(e), sep = ""))
satDF_new$`State Population` = sapply(satDF_new$`State Population`, function(e) format(e, big.mark=",", scientific=FALSE))
char_col = apply(satDF_new[, c(3, 5, 6, 7, 8)], 2, as.character)
satDF_pretty = data.frame(STATE = satDF_new$State,
REGION = satDF_new$Region,
POPULATION = satDF_new$`State Population`,
EXPENDITURE = satDF_new$Expenditure,
TEACHER_SALARY = satDF_new$`Teacher Salary`,
STUDENT_TEACHER_RATIO = char_col[ , 1],
ELIGIBLE_STUDENT_FRACTION = char_col[ , 2],
SAT_TOTAL_SCORE = char_col[ , 5],
SAT_MATH_SCORE = char_col[ , 4],
SAT_VERBAL_SCORE = char_col[ , 3])
satDF_pretty= rename(satDF_pretty, c("STATE" = "STATE",
"REGION" = "REGION",
"POPULATION" = "POPULATION",
"EXPENDITURE" = "EXPENDITURE (in thousands of dollars)",
"TEACHER_SALARY" = "TEACHER SALARY (in thousands of dollars)",
"STUDENT_TEACHER_RATIO" = "STUDENT-TEACHER RATIO",
"ELIGIBLE_STUDENT_FRACTION" = "ELIGIBLE STUDENT FRACTION",
"SAT_TOTAL_SCORE" = "SAT TOTAL SCORE",
"SAT_MATH_SCORE" = "SAT MATH SCORE",
"SAT_VERBAL_SCORE" = "SAT VERBAL SCORE"))
satDF_pretty = format(satDF_pretty, justify = "right")
save(satDF_pretty, file = "../rda_data/satDF_pretty.rda")
load("../rda_data/satDF_pretty.rda")
View(satDF_pretty)
setwd("~/Dropbox/Senior_Research/Stat_Summer15_Research/DynDocs/SAT/shiny_html_table1/")
library(shiny)
runApp("show_data_app/")
setwd("~/Dropbox/Senior_Research/Stat_Summer15_Research/DynDocs/SAT/doc_0.1")
library(shiny)
runApp("SATapp/")
setwd("~/Dropbox/Senior_Research/Stat_Summer15_Research/DynDocs/SAT/doc_0.1")
library(shiny)
runApp("SATapp/")
setwd("~/Dropbox/Senior_Research/Stat_Summer15_Research/DynDocs/SAT/doc_0.1")
library(shiny)
runApp("SATapp/")
